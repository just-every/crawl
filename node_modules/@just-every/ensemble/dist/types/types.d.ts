export type ToolParameterType = 'string' | 'number' | 'boolean' | 'object' | 'array' | 'null';
export interface ToolParameter {
    type?: ToolParameterType;
    description?: string | (() => string);
    enum?: string[] | (() => Promise<string[]>);
    items?: ToolParameter | {
        type: ToolParameterType;
        enum?: string[] | (() => Promise<string[]>);
    };
    properties?: Record<string, ToolParameter>;
    required?: string[];
    optional?: boolean;
    minItems?: number;
    additionalProperties?: boolean;
    default?: unknown;
    minimum?: number;
    maximum?: number;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
}
export type ExecutableFunction = (...args: unknown[]) => Promise<string> | string;
export interface ToolFunction {
    function: ExecutableFunction;
    definition: ToolDefinition;
    injectAgentId?: boolean;
    injectAbortSignal?: boolean;
}
export interface ToolDefinition {
    type: 'function';
    function: {
        name: string;
        description: string;
        parameters: {
            type: 'object';
            properties: Record<string, ToolParameter>;
            required: string[];
        };
    };
}
export interface ResponseJSONSchema {
    name: string;
    schema: Record<string, unknown>;
    type: 'json_schema';
    description?: string;
    strict?: boolean | null;
}
export interface ModelSettings {
    temperature?: number;
    top_p?: number;
    top_k?: number;
    max_tokens?: number;
    stop_sequence?: string;
    seed?: number;
    text?: {
        format: string;
    };
    tool_choice?: 'auto' | 'none' | 'required' | {
        type: string;
        function: {
            name: string;
        };
    };
    sequential_tools?: boolean;
    json_schema?: ResponseJSONSchema;
    force_json?: boolean;
}
export interface ToolCall {
    id: string;
    type: 'function';
    call_id?: string;
    function: {
        name: string;
        arguments: string;
    };
}
export interface ToolCallResult {
    toolCall: ToolCall;
    id: string;
    call_id: string;
    output?: string;
    error?: string;
}
export interface ToolCallHandler {
    onToolCall?: (toolCall: ToolCall) => void;
    onToolResult?: (toolCall: ToolCall, result: string) => void;
}
export interface ResponseContentText {
    type: 'input_text';
    text: string;
}
export interface ResponseContentImage {
    type: 'input_image';
    detail: 'high' | 'low' | 'auto';
    file_id?: string;
    image_url?: string;
}
export interface ResponseContentFileInput {
    type: 'input_file';
    file_data?: string;
    file_id?: string;
    filename?: string;
}
export type ResponseContent = string | Array<ResponseContentText | ResponseContentImage | ResponseContentFileInput>;
export type ResponseInput = Array<ResponseInputItem>;
export type ResponseInputItem = ResponseInputMessage | ResponseThinkingMessage | ResponseOutputMessage | ResponseInputFunctionCall | ResponseInputFunctionCallOutput;
export interface ResponseBaseMessage {
    type: string;
    model?: string;
    timestamp?: number;
}
export interface ResponseInputMessage extends ResponseBaseMessage {
    type: 'message';
    name?: string;
    content: ResponseContent;
    role: 'user' | 'system' | 'developer';
    status?: 'in_progress' | 'completed' | 'incomplete';
}
export interface ResponseThinkingMessage extends ResponseBaseMessage {
    type: 'thinking';
    content: ResponseContent;
    signature?: ResponseContent;
    thinking_id?: string;
    role: 'assistant';
    status?: 'in_progress' | 'completed' | 'incomplete';
}
export interface ResponseOutputMessage extends ResponseBaseMessage {
    id?: string;
    type: 'message';
    content: ResponseContent;
    role: 'assistant';
    status: 'in_progress' | 'completed' | 'incomplete';
}
export interface ResponseInputFunctionCall extends ResponseBaseMessage {
    type: 'function_call';
    call_id: string;
    name: string;
    arguments: string;
    id?: string;
    status?: 'in_progress' | 'completed' | 'incomplete';
}
export interface ResponseInputFunctionCallOutput extends ResponseBaseMessage {
    type: 'function_call_output';
    call_id: string;
    name?: string;
    output: string;
    id?: string;
    status?: 'in_progress' | 'completed' | 'incomplete';
}
export type StreamEventType = 'connected' | 'command_start' | 'command_done' | 'project_create' | 'project_update' | 'process_start' | 'process_running' | 'process_updated' | 'process_done' | 'process_failed' | 'process_waiting' | 'process_terminated' | 'agent_start' | 'agent_updated' | 'agent_done' | 'agent_status' | 'message_start' | 'message_delta' | 'message_complete' | 'audio_stream' | 'tool_start' | 'tool_delta' | 'tool_done' | 'file_start' | 'file_delta' | 'file_complete' | 'cost_update' | 'system_status' | 'system_update' | 'quota_update' | 'screenshot' | 'design_grid' | 'console' | 'error' | 'response_output' | 'tool_wait_start' | 'tool_waiting' | 'tool_wait_complete' | 'task_wait_start' | 'task_waiting' | 'task_wait_complete' | 'task_complete' | 'task_fatal_error' | 'git_pull_request' | 'stream_end' | 'agent_start' | 'agent_status' | 'agent_done';
export interface StreamEventBase {
    type: StreamEventType;
    timestamp?: string;
    agent?: AgentExportDefinition;
}
export interface MessageEventBase extends StreamEventBase {
    type: StreamEventType;
    content: string;
    message_id: string;
    order?: number;
    thinking_content?: string;
    thinking_signature?: string;
}
export interface MessageEvent extends MessageEventBase {
    type: 'message_start' | 'message_delta' | 'message_complete';
}
export interface FileEvent extends StreamEventBase {
    type: 'file_start' | 'file_delta' | 'file_complete';
    message_id: string;
    mime_type?: string;
    data_format: 'base64';
    data: string;
    order?: number;
}
export interface ToolEvent extends StreamEventBase {
    type: 'tool_start' | 'tool_delta' | 'tool_done';
    tool_call: ToolCall;
    result?: {
        call_id: string;
        output: string;
        error?: string;
    };
}
export interface ErrorEvent extends StreamEventBase {
    type: 'error';
    error: string;
}
export interface TaskEvent extends StreamEventBase {
    type: 'task_complete' | 'task_fatal_error';
    result?: string;
}
export interface CostUpdateEvent extends StreamEventBase {
    type: 'cost_update';
    usage: {
        input_tokens: number;
        output_tokens: number;
        total_tokens?: number;
        cached_tokens?: number;
    };
    thought_delay?: number;
}
export interface ResponseOutputEvent extends StreamEventBase {
    type: 'response_output';
    message: ResponseInputItem;
}
export interface AgentEvent extends StreamEventBase {
    type: 'agent_start' | 'agent_status' | 'agent_done';
    agent: AgentExportDefinition;
    input?: string;
    output?: string;
    status?: string;
    parent_id?: string;
}
export type ProviderStreamEvent = StreamEventBase | MessageEvent | FileEvent | ToolEvent | ErrorEvent | CostUpdateEvent | ResponseOutputEvent | AgentEvent;
export interface ModelProvider {
    createResponseStream(messages: ResponseInput, model: string, agent: AgentDefinition): AsyncGenerator<ProviderStreamEvent>;
    createEmbedding?(input: string | string[], model: string, opts?: EmbedOpts): Promise<number[] | number[][]>;
    createImage?(prompt: string, model?: string, opts?: ImageGenerationOpts): Promise<string[]>;
    createVoice?(text: string, model: string, opts?: VoiceGenerationOpts): Promise<ReadableStream<Uint8Array> | ArrayBuffer>;
}
export type ModelClassID = 'standard' | 'mini' | 'reasoning' | 'reasoning_mini' | 'monologue' | 'metacognition' | 'code' | 'writing' | 'summary' | 'vision' | 'vision_mini' | 'search' | 'image_generation' | 'embedding' | 'voice';
export type ModelProviderID = 'openai' | 'anthropic' | 'google' | 'xai' | 'deepseek' | 'openrouter' | 'elevenlabs' | 'test';
export interface TieredPrice {
    threshold_tokens: number;
    price_below_threshold_per_million: number;
    price_above_threshold_per_million: number;
}
export interface TimeBasedPrice {
    peak_price_per_million: number;
    off_peak_price_per_million: number;
    peak_utc_start_hour: number;
    peak_utc_start_minute: number;
    peak_utc_end_hour: number;
    peak_utc_end_minute: number;
}
export interface ModelCost {
    input_per_million?: number | TieredPrice | TimeBasedPrice;
    output_per_million?: number | TieredPrice | TimeBasedPrice;
    cached_input_per_million?: number | TieredPrice | TimeBasedPrice;
    per_image?: number;
}
export interface ModelFeatures {
    context_length?: number;
    input_modality?: ('text' | 'image' | 'audio' | 'video')[];
    output_modality?: ('text' | 'image' | 'audio' | 'embedding')[];
    tool_use?: boolean;
    streaming?: boolean;
    json_output?: boolean;
    max_output_tokens?: number;
    reasoning_output?: boolean;
}
export interface ModelEntry {
    id: string;
    aliases?: string[];
    provider: ModelProviderID;
    cost: ModelCost;
    features: ModelFeatures;
    class?: string;
    description?: string;
    rate_limit_fallback?: string;
    openrouter_id?: string;
    embedding?: boolean;
    dim?: number;
    score?: number;
    scores?: {
        monologue?: number;
        code?: number;
        reasoning?: number;
    };
}
export interface ModelUsage {
    model: string;
    cost?: number;
    input_tokens?: number;
    output_tokens?: number;
    cached_tokens?: number;
    image_count?: number;
    metadata?: Record<string, unknown>;
    timestamp?: Date;
    isFreeTierUsage?: boolean;
}
export interface ModelClass {
    models: string[];
    random?: boolean;
}
export interface ModelSpecificQuota {
    model: string;
    dailyTokenLimit: number;
    dailyTokensUsed: number;
    dailyRequestLimit: number;
    dailyRequestsUsed: number;
    rateLimit?: {
        requestsPerMinute: number;
        tokensPerMinute: number;
    };
    lastResetDate?: Date;
}
export interface ProviderQuota {
    provider: ModelProviderID;
    creditBalance?: number;
    creditLimit?: number;
    info?: Record<string, unknown>;
    models: Record<string, ModelSpecificQuota>;
    lastResetDate?: Date;
}
export interface EnsembleLogger {
    log_llm_request(agentId: string, providerName: string, model: string, requestData: unknown, timestamp?: Date): string;
    log_llm_response(requestId: string | undefined, responseData: unknown, timestamp?: Date): void;
    log_llm_error(requestId: string | undefined, errorData: unknown, timestamp?: Date): void;
}
export interface ExtractBase64ImageResult {
    found: boolean;
    originalContent: string;
    replaceContent: string;
    image_id: string | null;
    images: Record<string, string>;
}
export interface EmbedOpts {
    taskType?: string;
    dimensions?: number;
    normalize?: boolean;
}
export interface ImageGenerationOpts {
    n?: number;
    size?: 'square' | 'landscape' | 'portrait' | '1024x1024' | '1536x1024' | '1024x1536' | '1792x1024' | '1024x1792' | '512x512' | '256x256';
    quality?: 'standard' | 'hd' | 'low' | 'medium' | 'high';
    style?: 'vivid' | 'natural';
    response_format?: 'url' | 'b64_json';
    source_images?: string | string[];
    mask?: string;
}
export interface VoiceGenerationOpts {
    voice?: 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer' | 'rachel' | 'domi' | 'bella' | 'antoni' | 'elli' | 'josh' | 'arnold' | 'adam' | 'sam' | 'george' | string;
    speed?: number;
    response_format?: 'mp3' | 'opus' | 'aac' | 'flac' | 'wav' | 'pcm' | 'mp3_low' | 'mp3_high' | 'pcm_16000' | 'pcm_22050' | 'pcm_24000' | 'pcm_44100' | 'ulaw';
    stream?: boolean;
    voice_settings?: {
        stability?: number;
        similarity_boost?: number;
        style?: number;
        use_speaker_boost?: boolean;
    };
}
export type WorkerFunction = (...args: any[]) => AgentDefinition;
export interface AgentExportDefinition {
    agent_id?: string;
    name?: string;
    parent_id?: string;
    model?: string;
    modelClass?: string;
    cwd?: string;
    modelScores?: Record<string, number>;
    disabledModels?: string[];
}
export interface AgentDefinition {
    agent_id?: string;
    name?: string;
    description?: string;
    instructions?: string;
    parent_id?: string;
    workers?: WorkerFunction[];
    tools?: ToolFunction[];
    model?: string;
    modelClass?: ModelClassID;
    modelSettings?: ModelSettings;
    intelligence?: 'low' | 'standard' | 'high';
    maxToolCalls?: number;
    maxToolCallRoundsPerTurn?: number;
    verifier?: AgentDefinition;
    maxVerificationAttempts?: number;
    args?: any;
    jsonSchema?: ResponseJSONSchema;
    historyThread?: ResponseInput | undefined;
    cwd?: string;
    modelScores?: Record<string, number>;
    disabledModels?: string[];
    getTools?: () => Promise<ToolFunction[]>;
    onToolCall?: (toolCall: ToolCall) => Promise<void>;
    processToolCall?: (toolCalls: ToolCall[]) => Promise<Record<string, any>>;
    onToolResult?: (toolCallResult: ToolCallResult) => Promise<void>;
    onToolError?: (toolCallResult: ToolCallResult) => Promise<void>;
    onRequest?: (agent: AgentDefinition, messages: ResponseInput) => Promise<[any, ResponseInput]>;
    onResponse?: (message: ResponseOutputMessage) => Promise<void>;
    onThinking?: (message: ResponseThinkingMessage) => Promise<void>;
    onToolEvent?: (event: ProviderStreamEvent) => void | Promise<void>;
    params?: ToolParameterMap;
    processParams?: (agent: AgentDefinition, params: Record<string, any>) => Promise<{
        prompt: string;
        intelligence?: 'low' | 'standard' | 'high';
    }>;
    abortSignal?: AbortSignal;
    retryOptions?: {
        maxRetries?: number;
        initialDelay?: number;
        maxDelay?: number;
        backoffMultiplier?: number;
        additionalRetryableErrors?: string[];
        additionalRetryableStatusCodes?: number[];
        onRetry?: (error: any, attempt: number) => void;
    };
}
export interface ToolParameter {
    type?: ToolParameterType;
    description?: string | (() => string);
    enum?: string[] | (() => Promise<string[]>);
    items?: ToolParameter | {
        type: ToolParameterType;
        enum?: string[] | (() => Promise<string[]>);
    };
    properties?: Record<string, ToolParameter>;
    required?: string[];
    optional?: boolean;
    minItems?: number;
    additionalProperties?: boolean;
    default?: unknown;
    minimum?: number;
    maximum?: number;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
}
export type ToolParameterMap = Record<string, string | ToolParameter>;
//# sourceMappingURL=types.d.ts.map
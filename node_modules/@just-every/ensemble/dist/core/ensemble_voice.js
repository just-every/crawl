import { getModelFromAgent, getModelProvider, } from '../model_providers/model_provider.js';
export async function ensembleVoice(text, agent, options = {}) {
    const model = await getModelFromAgent(agent, 'voice');
    const provider = getModelProvider(model);
    if (!provider.createVoice) {
        throw new Error(`Provider for model ${model} does not support voice generation`);
    }
    return provider.createVoice(text, model, options);
}
export async function* ensembleVoiceStream(text, agent, options = {}) {
    const streamOptions = { ...options, stream: true };
    await getModelFromAgent(agent, 'voice');
    const format = options.response_format || 'mp3';
    const isPCM = format.includes('pcm');
    yield {
        type: 'audio_stream',
        timestamp: new Date().toISOString(),
        format: format,
        ...(isPCM && {
            pcmParameters: {
                sampleRate: format === 'pcm_44100'
                    ? 44100
                    : format === 'pcm_22050'
                        ? 22050
                        : format === 'pcm_16000'
                            ? 16000
                            : 24000,
                channels: 1,
                bitDepth: 16,
            },
        }),
    };
    const result = await ensembleVoice(text, agent, streamOptions);
    if (!(result instanceof ReadableStream)) {
        throw new Error('Expected streaming response but got buffer');
    }
    const reader = result.getReader();
    const CHUNK_SIZE = 8192;
    let buffer = new Uint8Array(0);
    let chunkIndex = 0;
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (value) {
                const newBuffer = new Uint8Array(buffer.length + value.length);
                newBuffer.set(buffer);
                newBuffer.set(value, buffer.length);
                buffer = newBuffer;
            }
            while (buffer.length >= CHUNK_SIZE || (done && buffer.length > 0)) {
                const chunkSize = Math.min(CHUNK_SIZE, buffer.length);
                const chunk = buffer.slice(0, chunkSize);
                buffer = buffer.slice(chunkSize);
                const base64Chunk = Buffer.from(chunk).toString('base64');
                const isFinalChunk = done && buffer.length === 0;
                yield {
                    type: 'audio_stream',
                    chunkIndex: chunkIndex++,
                    isFinalChunk: isFinalChunk,
                    data: base64Chunk,
                    timestamp: new Date().toISOString(),
                };
                if (isFinalChunk)
                    break;
            }
            if (done)
                break;
        }
    }
    finally {
        reader.releaseLock();
    }
    try {
        const costTrackerModule = await import('../utils/cost_tracker.js');
        const costTracker = costTrackerModule.costTracker;
        const usage = costTracker.entries || [];
        if (usage.length > 0) {
            const latestUsage = usage[usage.length - 1];
            yield {
                type: 'cost_update',
                usage: latestUsage,
            };
        }
    }
    catch (error) {
        console.debug('Cost tracking not available:', error);
    }
}
//# sourceMappingURL=ensemble_voice.js.map
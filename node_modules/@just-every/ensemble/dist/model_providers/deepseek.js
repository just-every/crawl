import { OpenAIChat } from './openai_chat.js';
function formatToolsForPrompt(tools) {
    if (!tools || tools.length === 0) {
        return 'No tools are available for use.';
    }
    const toolDescriptions = tools
        .map(tool => {
        if (tool.type !== 'function' || !tool.function) {
            return `  - Unknown tool type: ${tool.type}`;
        }
        const func = tool.function;
        const parameters = func.parameters && typeof func.parameters === 'object'
            ? func.parameters
            : {};
        const properties = 'properties' in parameters ? parameters.properties : {};
        const requiredParams = 'required' in parameters && Array.isArray(parameters.required)
            ? parameters.required
            : [];
        const paramsJson = JSON.stringify(properties, null, 2);
        return `  - Name: ${func.name}\n    Description: ${func.description || 'No description'}\n    Parameters (JSON Schema): ${paramsJson}\n    Required Parameters: ${requiredParams.join(', ') || 'None'}`;
    })
        .join('\n\n');
    return `You have the following tools available:\n${toolDescriptions}\n\nTo use one or more tools, output the following JSON structure containing an ARRAY of tool calls on a new line *at the very end* of your response, and *only* if you intend to call tool(s). Ensure the arguments value in each call is a JSON *string*: \n\`\`\`json\nTOOL_CALLS: [ {"id": "call_001", "type": "function", "function": {"name": "function_name_1", "arguments": "{\\"arg1\\": \\"value1\\"}"}}, {"id": "call_002", "type": "function", "function": {"name": "function_name_2", "arguments": "{\\"argA\\": true, \\"argB\\": 123}"}} ]\n\`\`\`\nReplace \`function_name\` and arguments accordingly for each tool call you want to make. Put all desired calls in the array. IMPORTANT: Always include an 'id' field with a unique string for each call. Do not add any text after the TOOL_CALLS line. If you are not calling any tools, respond normally without the TOOL_CALLS structure.`;
}
export class DeepSeekProvider extends OpenAIChat {
    constructor() {
        super('deepseek', process.env.DEEPSEEK_API_KEY, 'https://api.deepseek.com/v1');
    }
    prepareParameters(requestParams) {
        if (requestParams.model === 'deepseek-reasoner') {
            const originalTools = requestParams.tools ?? [];
            requestParams.max_tokens = 8000;
            delete requestParams.tools;
            delete requestParams.response_format;
            delete requestParams.logprobs;
            delete requestParams.top_logprobs;
            if ('tool_choice' in requestParams) {
                delete requestParams.tool_choice;
            }
            let messages = [...requestParams.messages];
            const toolInfoForPrompt = formatToolsForPrompt(originalTools);
            if (toolInfoForPrompt) {
                messages.push({ role: 'system', content: toolInfoForPrompt });
            }
            messages = messages.map(originalMessage => {
                let message = { ...originalMessage };
                if (message.role === 'assistant' && message.tool_calls) {
                    const calls = message.tool_calls
                        .map(toolCall => {
                        if (toolCall.type === 'function') {
                            const args = typeof toolCall.function.arguments ===
                                'string'
                                ? toolCall.function.arguments
                                : JSON.stringify(toolCall.function.arguments);
                            return `Called function '${toolCall.function.name}' with arguments: ${args}`;
                        }
                        return `(Unsupported tool call type: ${toolCall.type})`;
                    })
                        .join('\n');
                    message = {
                        role: 'assistant',
                        content: `[Previous Action] ${calls}`,
                    };
                }
                else if (message.role === 'tool') {
                    const contentString = typeof message.content === 'string'
                        ? message.content
                        : JSON.stringify(message.content);
                    const toolCallIdInfo = message.tool_call_id
                        ? ` for call ID ${message.tool_call_id}`
                        : '';
                    message = {
                        role: 'user',
                        content: `[Tool Result${toolCallIdInfo}] ${contentString}`,
                    };
                }
                if (typeof message.content !== 'string') {
                    message.content = JSON.stringify(message.content);
                }
                return message;
            });
            if (messages.length === 0 ||
                messages[messages.length - 1].role !== 'user') {
                const aiName = process.env.AI_NAME || 'Magi';
                messages.push({
                    role: 'user',
                    content: `${aiName} thoughts: Let me think through this step by step...`,
                });
            }
            const systemContents = [];
            let finalMessages = [];
            messages.forEach(msg => {
                if (msg.role === 'system') {
                    if (msg.content && typeof msg.content === 'string') {
                        systemContents.push(msg.content);
                    }
                    else if (msg.content) {
                        try {
                            systemContents.push(JSON.stringify(msg.content));
                        }
                        catch (e) {
                            console.error(`(${this.provider}) Failed to stringify system message content:`, e);
                        }
                    }
                }
                else {
                    finalMessages.push(msg);
                }
            });
            finalMessages = finalMessages.reduce((acc, currentMessage) => {
                const lastMessage = acc.length > 0 ? acc[acc.length - 1] : null;
                if (lastMessage &&
                    lastMessage.role === currentMessage.role) {
                    lastMessage.content = `${lastMessage.content ?? ''}\n\n${currentMessage.content ?? ''}`;
                }
                else {
                    acc.push({ ...currentMessage });
                }
                return acc;
            }, []);
            if (systemContents.length > 0) {
                finalMessages.unshift({
                    role: 'system',
                    content: systemContents.join('\n\n'),
                });
            }
            requestParams.messages = finalMessages;
        }
        else {
            return super.prepareParameters(requestParams);
        }
        return requestParams;
    }
}
export const deepSeekProvider = new DeepSeekProvider();
//# sourceMappingURL=deepseek.js.map
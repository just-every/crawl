import { ProviderStreamEvent, ToolCall } from '../types/types.js';
export interface MockToolCall {
    name: string;
    arguments: Record<string, any>;
}
export interface MockResponse {
    message?: string;
    toolCalls?: MockToolCall[];
    error?: Error | string;
    delay?: number;
    thinking?: string;
}
export interface MockStreamOptions {
    onToolCall?: (call: ToolCall) => void;
    includeThinking?: boolean;
}
export declare class EnhancedRequestMock {
    private responses;
    private callIndex;
    constructor(responses: MockResponse | MockResponse[]);
    getMock(): (model: string, messages: any, options: any) => AsyncGenerator<ProviderStreamEvent, any, any>;
    private createAsyncGenerator;
    static success(message?: string, result?: string): EnhancedRequestMock;
    static error(message?: string, error?: string): EnhancedRequestMock;
    static throws(error: Error | string): EnhancedRequestMock;
    static thinking(thinking: string, message: string): EnhancedRequestMock;
    static toolCalls(...calls: MockToolCall[]): EnhancedRequestMock;
    static sequence(...responses: MockResponse[]): EnhancedRequestMock;
}
export declare function createMockContext(overrides?: Partial<any>): {
    shouldContinue: boolean;
    metadata: {};
    toolCallCount: number;
    turnCount: number;
    startTime: number;
    messages: any[];
    isPaused: boolean;
    isHalted: boolean;
    halt: import("vitest").Mock<() => void>;
    pause: import("vitest").Mock<() => void>;
    resume: import("vitest").Mock<() => void>;
    setMetadata: import("vitest").Mock<(key: string, value: any) => void>;
    getMetadata: import("vitest").Mock<(key: string) => any>;
    addMessage: import("vitest").Mock<(message: any) => void>;
    getHistory: import("vitest").Mock<() => any>;
};
export declare class StreamAssertions {
    private events;
    constructor(eventGenerator: AsyncGenerator<ProviderStreamEvent>);
    waitForCompletion(): Promise<void>;
    hasEvent(type: string): boolean;
    getEvents(type: string): ProviderStreamEvent[];
    hasToolCall(name: string): boolean;
    getFinalMessage(): string | undefined;
    hasError(): boolean;
    getError(): string | undefined;
}
//# sourceMappingURL=test_utils.d.ts.map
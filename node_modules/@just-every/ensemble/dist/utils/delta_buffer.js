export class DeltaBuffer {
    step;
    max;
    timeLimitMs;
    buffer = '';
    startTimestamp = null;
    threshold;
    constructor(step = 20, max = 400, initial = 20, timeLimitMs = 10_000) {
        this.step = step;
        this.max = max;
        this.timeLimitMs = timeLimitMs;
        this.threshold = initial;
    }
    add(chunk) {
        this.buffer += chunk;
        if (this.startTimestamp === null)
            this.startTimestamp = Date.now();
        const shouldFlushBySize = this.buffer.length >= this.threshold;
        const shouldFlushByTime = this.startTimestamp !== null &&
            Date.now() - this.startTimestamp >= this.timeLimitMs;
        if (shouldFlushBySize || shouldFlushByTime) {
            const out = this.buffer;
            this.buffer = '';
            this.startTimestamp = null;
            if (shouldFlushBySize && this.threshold < this.max) {
                this.threshold += this.step;
            }
            return out;
        }
        return null;
    }
    flush() {
        if (!this.buffer)
            return null;
        const out = this.buffer;
        this.buffer = '';
        this.startTimestamp = null;
        return out;
    }
}
export function bufferDelta(store, messageId, chunk, makeEvent) {
    let buf = store.get(messageId);
    if (!buf) {
        buf = new DeltaBuffer();
        store.set(messageId, buf);
    }
    const out = buf.add(chunk);
    return out !== null ? [makeEvent(out)] : [];
}
export function flushBufferedDeltas(store, makeEvent) {
    const events = [];
    for (const [id, buf] of store) {
        const out = buf.flush();
        if (out !== null)
            events.push(makeEvent(id, out));
    }
    store.clear();
    return events;
}
//# sourceMappingURL=delta_buffer.js.map
import { MAX_RESULT_LENGTH, SKIP_SUMMARIZATION_TOOLS, TOOL_CONFIGS, } from '../config/tool_execution.js';
import crypto from 'crypto';
const SUMMARIZE_AT_CHARS = 5000;
const SUMMARIZE_TRUNCATE_CHARS = 200000;
const summaryCache = new Map();
const CACHE_EXPIRATION_MS = 60 * 60 * 1000;
const FAILURE_PATTERNS = [
    /error|exception|failed|timeout|rejected|unable to|cannot|not found|invalid/gi,
    /retry.*attempt|retrying|trying again/gi,
    /no (?:such|valid) (?:file|directory|path|route)/gi,
    /unexpected|unknown|unhandled/gi,
];
const MAX_RETRIES = 3;
const ERROR_FREQUENCY_THRESHOLD = 0.3;
function truncate(text, length = SUMMARIZE_TRUNCATE_CHARS, separator = '\n\n...[truncated for summary]...\n\n') {
    text = text.trim();
    if (text.length <= length) {
        return text;
    }
    const beginLength = Math.floor(length * 0.3);
    const endLength = length - beginLength - separator.length;
    return (text.substring(0, beginLength) +
        separator +
        text.substring(text.length - endLength));
}
export async function createSummary(content, prompt) {
    if (content.length <= SUMMARIZE_AT_CHARS) {
        return content;
    }
    const contentHash = crypto
        .createHash('sha256')
        .update(content)
        .digest('hex');
    const cacheKey = `${contentHash}-${prompt.substring(0, 50)}`;
    const cachedSummary = summaryCache.get(cacheKey);
    if (cachedSummary &&
        Date.now() - cachedSummary.timestamp < CACHE_EXPIRATION_MS) {
        console.log(`Retrieved summary from cache for hash: ${contentHash.substring(0, 8)}...`);
        return cachedSummary.summary;
    }
    try {
        const truncatedContent = truncate(content, SUMMARIZE_TRUNCATE_CHARS);
        const originalLines = content.split('\n').length;
        const { ensembleRequest } = await import('../core/ensemble_request.js');
        const messages = [
            {
                type: 'message',
                role: 'system',
                content: prompt,
            },
            {
                type: 'message',
                role: 'user',
                content: truncatedContent,
            },
        ];
        const agent = {
            modelClass: 'summary',
            name: 'SummaryAgent',
        };
        let summary = '';
        for await (const event of ensembleRequest(messages, agent)) {
            if (event.type === 'message_complete' && 'content' in event) {
                summary += event.content;
            }
        }
        if (!summary) {
            throw new Error('No summary generated');
        }
        const trimmedSummary = summary.trim();
        const summaryLines = trimmedSummary.split('\n').length;
        const metadata = `\n\n[Summarized output: ${originalLines} → ${summaryLines} lines, ${content.length} → ${trimmedSummary.length} chars]`;
        const fullSummary = trimmedSummary + metadata;
        summaryCache.set(cacheKey, {
            summary: fullSummary,
            timestamp: Date.now(),
        });
        return fullSummary;
    }
    catch (error) {
        console.error('Error creating summary:', error);
        const truncated = truncate(content, MAX_RESULT_LENGTH);
        return truncated + '\n\n[Summary generation failed, output truncated]';
    }
}
export async function processToolResult(toolCall, rawResult) {
    const toolName = toolCall.function.name;
    const config = TOOL_CONFIGS[toolName] || {};
    if (rawResult.startsWith('data:image/')) {
        return rawResult;
    }
    const skipSummarization = config.skipSummarization || SKIP_SUMMARIZATION_TOOLS.has(toolName);
    const maxLength = config.maxLength || MAX_RESULT_LENGTH;
    if (skipSummarization) {
        if (rawResult.length > maxLength) {
            const truncatedResult = truncate(rawResult, maxLength);
            const truncationMessage = config.truncationMessage ||
                `\n\n[Output truncated: ${rawResult.length} → ${maxLength} chars]`;
            return truncatedResult + truncationMessage;
        }
        return rawResult;
    }
    const summarizeThreshold = Math.max(maxLength, SUMMARIZE_AT_CHARS);
    if (rawResult.length <= summarizeThreshold) {
        return rawResult;
    }
    const potentialIssues = detectPotentialIssues(rawResult);
    let summaryPrompt = `The following is the output of a tool call \`${toolName}(${toolCall.function.arguments})\` used by an AI agent in an autonomous system. Focus on summarizing both the overall output and the final result of the tool. Your summary will be used to understand what the result of the tool call was.`;
    if (potentialIssues.isLikelyFailing) {
        summaryPrompt += ` Note: The output appears to contain errors or issues. Please highlight any errors, failures, or problems in your summary.`;
    }
    const summary = await createSummary(rawResult, summaryPrompt);
    if (potentialIssues.isLikelyFailing && potentialIssues.issues.length > 0) {
        return (summary +
            `\n\n⚠️ Potential issues detected: ${potentialIssues.issues.join(', ')}`);
    }
    return summary;
}
export function shouldSummarizeResult(toolName, resultLength) {
    const config = TOOL_CONFIGS[toolName] || {};
    if (config.skipSummarization || SKIP_SUMMARIZATION_TOOLS.has(toolName)) {
        return false;
    }
    const maxLength = config.maxLength || MAX_RESULT_LENGTH;
    return resultLength > maxLength;
}
export function getTruncationMessage(toolName) {
    const config = TOOL_CONFIGS[toolName] || {};
    return (config.truncationMessage ||
        `... Output truncated to ${config.maxLength || MAX_RESULT_LENGTH} characters`);
}
function detectPotentialIssues(output) {
    if (!output) {
        return { isLikelyFailing: false, issues: [] };
    }
    let errorCount = 0;
    let retryCount = 0;
    const issues = [];
    FAILURE_PATTERNS.forEach(pattern => {
        const matches = output.match(pattern);
        if (matches) {
            errorCount += matches.length;
        }
    });
    const retryMatches = output.match(/retry.*attempt|retrying|trying again/gi);
    if (retryMatches) {
        retryCount += retryMatches.length;
    }
    const errorFrequency = output.length > 0 ? errorCount / output.length : 0;
    const isLikelyFailing = retryCount > MAX_RETRIES || errorFrequency > ERROR_FREQUENCY_THRESHOLD;
    if (retryCount > MAX_RETRIES) {
        issues.push(`excessive retries (${retryCount})`);
    }
    if (errorFrequency > ERROR_FREQUENCY_THRESHOLD) {
        issues.push(`high error frequency (${(errorFrequency * 100).toFixed(1)}%)`);
    }
    return { isLikelyFailing, issues };
}
export function clearSummaryCache() {
    summaryCache.clear();
}
export function getSummaryCacheStats() {
    let oldestTimestamp = null;
    summaryCache.forEach(({ timestamp }) => {
        if (oldestTimestamp === null || timestamp < oldestTimestamp) {
            oldestTimestamp = timestamp;
        }
    });
    return {
        size: summaryCache.size,
        oldestEntry: oldestTimestamp,
    };
}
//# sourceMappingURL=tool_result_processor.js.map
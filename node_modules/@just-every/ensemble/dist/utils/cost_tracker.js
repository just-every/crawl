import { findModel, } from '../data/model_data.js';
class CostTracker {
    entries = [];
    started = new Date();
    onAddUsageCallbacks = [];
    calculateCost(usage) {
        if (typeof usage.cost === 'number') {
            return usage;
        }
        if (usage.isFreeTierUsage) {
            usage.cost = 0;
            return usage;
        }
        const model = findModel(usage.model);
        if (!model) {
            console.error(`Model not found when recording usage: ${usage.model}`);
            throw new Error(`Model not found when recording usage: ${usage.model}`);
        }
        usage.cost = 0;
        const original_input_tokens = usage.input_tokens || 0;
        const output_tokens = usage.output_tokens || 0;
        const cached_tokens = usage.cached_tokens || 0;
        const image_count = usage.image_count || 0;
        const calculationTime = usage.timestamp || new Date();
        const usesTimeBasedPricing = (typeof model.cost?.input_per_million === 'object' &&
            model.cost.input_per_million !== null &&
            'peak_price_per_million' in model.cost.input_per_million) ||
            (typeof model.cost?.output_per_million === 'object' &&
                model.cost.output_per_million !== null &&
                'peak_price_per_million' in model.cost.output_per_million) ||
            (typeof model.cost?.cached_input_per_million === 'object' &&
                model.cost.cached_input_per_million !== null &&
                'peak_price_per_million' in
                    model.cost.cached_input_per_million);
        if (!usage.timestamp && usesTimeBasedPricing) {
            console.warn(`Timestamp missing for time-based pricing model '${usage.model}'. Defaulting to current time for calculation.`);
        }
        const getPrice = (tokensForTierCheck, costStructure) => {
            if (typeof costStructure === 'number') {
                return costStructure;
            }
            if (typeof costStructure === 'object' && costStructure !== null) {
                if ('peak_price_per_million' in costStructure) {
                    const timeBasedCost = costStructure;
                    const utcHour = calculationTime.getUTCHours();
                    const utcMinute = calculationTime.getUTCMinutes();
                    const currentTimeInMinutes = utcHour * 60 + utcMinute;
                    const peakStartInMinutes = timeBasedCost.peak_utc_start_hour * 60 +
                        timeBasedCost.peak_utc_start_minute;
                    const peakEndInMinutes = timeBasedCost.peak_utc_end_hour * 60 +
                        timeBasedCost.peak_utc_end_minute;
                    let isPeakTime;
                    if (peakStartInMinutes <= peakEndInMinutes) {
                        isPeakTime =
                            currentTimeInMinutes >= peakStartInMinutes &&
                                currentTimeInMinutes < peakEndInMinutes;
                    }
                    else {
                        isPeakTime =
                            currentTimeInMinutes >= peakStartInMinutes ||
                                currentTimeInMinutes < peakEndInMinutes;
                    }
                    return isPeakTime
                        ? timeBasedCost.peak_price_per_million
                        : timeBasedCost.off_peak_price_per_million;
                }
                else if ('threshold_tokens' in costStructure) {
                    const tieredCost = costStructure;
                    if (tokensForTierCheck <= tieredCost.threshold_tokens) {
                        return tieredCost.price_below_threshold_per_million;
                    }
                    else {
                        return tieredCost.price_above_threshold_per_million;
                    }
                }
            }
            return 0;
        };
        let nonCachedInputTokens = 0;
        let actualCachedTokens = 0;
        if (cached_tokens > 0 &&
            model.cost?.cached_input_per_million !== undefined) {
            actualCachedTokens = cached_tokens;
            nonCachedInputTokens = Math.max(0, original_input_tokens - cached_tokens);
        }
        else {
            nonCachedInputTokens = original_input_tokens;
            actualCachedTokens = 0;
        }
        if (nonCachedInputTokens > 0 &&
            model.cost?.input_per_million !== undefined) {
            const inputPricePerMillion = getPrice(original_input_tokens, model.cost.input_per_million);
            usage.cost +=
                (nonCachedInputTokens / 1000000) * inputPricePerMillion;
        }
        if (actualCachedTokens > 0 &&
            model.cost?.cached_input_per_million !== undefined) {
            const cachedPricePerMillion = getPrice(actualCachedTokens, model.cost.cached_input_per_million);
            usage.cost +=
                (actualCachedTokens / 1000000) * cachedPricePerMillion;
        }
        if (output_tokens > 0 && model.cost?.output_per_million !== undefined) {
            const outputPricePerMillion = getPrice(output_tokens, model.cost.output_per_million);
            usage.cost += (output_tokens / 1000000) * outputPricePerMillion;
        }
        if (image_count > 0 && model.cost?.per_image) {
            usage.cost += image_count * model.cost.per_image;
        }
        usage.cost = Math.max(0, usage.cost);
        return usage;
    }
    onAddUsage(callback) {
        this.onAddUsageCallbacks.push(callback);
    }
    addUsage(usage) {
        try {
            usage = this.calculateCost({ ...usage });
            usage.timestamp = new Date();
            this.entries.push(usage);
            for (const callback of this.onAddUsageCallbacks) {
                try {
                    callback(usage);
                }
                catch (error) {
                    console.error('Error in cost tracker callback:', error);
                }
            }
        }
        catch (err) {
            console.error('Error recording usage:', err);
        }
    }
    getTotalCost() {
        return this.entries.reduce((sum, entry) => sum + (entry.cost || 0), 0);
    }
    getCostsByModel() {
        const models = {};
        for (const entry of this.entries) {
            if (!models[entry.model]) {
                models[entry.model] = {
                    cost: 0,
                    calls: 0,
                };
            }
            models[entry.model].cost += entry.cost || 0;
            models[entry.model].calls += 1;
        }
        return models;
    }
    printSummary() {
        if (!this.entries.length) {
            return;
        }
        const totalCost = this.getTotalCost();
        const costsByModel = this.getCostsByModel();
        const runtime = Math.round((new Date().getTime() - this.started.getTime()) / 1000);
        console.log('\n\nCOST SUMMARY');
        console.log(`Runtime: ${runtime} seconds`);
        console.log(`Total API Cost: $${totalCost.toFixed(6)}`);
        console.log('\nModels:');
        for (const [model, modelData] of Object.entries(costsByModel)) {
            console.log(`\t${model}:\t$${modelData.cost.toFixed(6)} (${modelData.calls} calls)`);
        }
        this.reset();
    }
    reset() {
        this.entries = [];
        this.started = new Date();
    }
}
const globalObj = globalThis;
if (!globalObj.__ENSEMBLE_COST_TRACKER__) {
    globalObj.__ENSEMBLE_COST_TRACKER__ = new CostTracker();
}
export const costTracker = globalObj.__ENSEMBLE_COST_TRACKER__;
export { CostTracker };
//# sourceMappingURL=cost_tracker.js.map
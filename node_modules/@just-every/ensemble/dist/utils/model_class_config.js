import { MODEL_CLASSES, findModel } from '../data/model_data.js';
import { overrideModelClass as _overrideModelClass, getModelClassOverride, } from './external_models.js';
export function getModelClass(className) {
    if (!(className in MODEL_CLASSES)) {
        return undefined;
    }
    const baseConfig = MODEL_CLASSES[className];
    const override = getModelClassOverride(className);
    if (!override) {
        return { ...baseConfig };
    }
    return {
        ...baseConfig,
        ...override,
        models: override.models || baseConfig.models,
    };
}
export function getModelClassNames() {
    return Object.keys(MODEL_CLASSES);
}
export function overrideModelClass(className, config) {
    if (!(className in MODEL_CLASSES)) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    if (config.models) {
        for (const modelId of config.models) {
            if (!findModel(modelId)) {
                console.warn(`Model '${modelId}' not found in registry, but adding to class '${className}' anyway`);
            }
        }
    }
    _overrideModelClass(className, config);
}
export function setModelClassModels(className, models, random) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    overrideModelClass(className, {
        models,
        random: random !== undefined ? random : currentConfig.random,
    });
}
export function addModelToClass(className, modelId) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    if (currentConfig.models.includes(modelId)) {
        return;
    }
    const newModels = [...currentConfig.models, modelId];
    setModelClassModels(className, newModels);
}
export function removeModelFromClass(className, modelId) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    const newModels = currentConfig.models.filter(id => id !== modelId);
    if (newModels.length < currentConfig.models.length) {
        setModelClassModels(className, newModels);
    }
}
export function setModelClassRandom(className, random) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    overrideModelClass(className, {
        models: currentConfig.models,
        random,
    });
}
export function resetModelClass(className) {
    overrideModelClass(className, {});
}
export function getAllModelClasses() {
    const result = {};
    for (const className of getModelClassNames()) {
        const config = getModelClass(className);
        if (config) {
            result[className] = config;
        }
    }
    return result;
}
export function updateModelClasses(updates) {
    for (const [className, config] of Object.entries(updates)) {
        overrideModelClass(className, config);
    }
}
//# sourceMappingURL=model_class_config.js.map
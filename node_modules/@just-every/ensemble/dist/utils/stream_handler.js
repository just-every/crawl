import { isPaused, waitWhilePaused } from './pause_controller.js';
export class StreamHandler {
    options;
    constructor(options = {}) {
        this.options = options;
    }
    async *handleStream(stream, transformer) {
        const { pauseCheckInterval = 100, abortSignal, providerName = 'Unknown', modelName = 'Unknown', } = this.options;
        try {
            for await (const chunk of stream) {
                if (isPaused()) {
                    console.log(`[${providerName}] System paused during stream for model ${modelName}. Waiting...`);
                    await waitWhilePaused(pauseCheckInterval, abortSignal);
                    console.log(`[${providerName}] System resumed, continuing stream for model ${modelName}`);
                }
                const events = transformer(chunk);
                if (events) {
                    if (Array.isArray(events)) {
                        for (const event of events) {
                            yield event;
                        }
                    }
                    else {
                        yield events;
                    }
                }
            }
        }
        catch (error) {
            yield {
                type: 'error',
                error: error.message || 'Unknown streaming error',
                code: error.code,
                details: error.details,
                recoverable: error.recoverable,
                timestamp: new Date().toISOString(),
            };
        }
    }
}
export function createStreamHandler(options = {}) {
    return new StreamHandler(options);
}
export function createMessageDeltaTransformer(messageId) {
    let order = 0;
    return function transformMessageDelta(content) {
        return {
            type: 'message_delta',
            content,
            message_id: messageId,
            order: order++,
            timestamp: new Date().toISOString(),
        };
    };
}
export function createMessageCompleteTransformer(messageId) {
    return function transformMessageComplete(content) {
        return {
            type: 'message_complete',
            content,
            message_id: messageId,
            timestamp: new Date().toISOString(),
        };
    };
}
//# sourceMappingURL=stream_handler.js.map